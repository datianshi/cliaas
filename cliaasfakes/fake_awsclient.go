// Code generated by counterfeiter. DO NOT EDIT.
package cliaasfakes

import (
	"sync"

	"github.com/pivotal-cf/cliaas"
)

type FakeAWSClient struct {
	CreateVMStub        func(ami, name string, vmInfo cliaas.VMInfo) (string, error)
	createVMMutex       sync.RWMutex
	createVMArgsForCall []struct {
		ami    string
		name   string
		vmInfo cliaas.VMInfo
	}
	createVMReturns struct {
		result1 string
		result2 error
	}
	createVMReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteVMStub        func(instanceID string) error
	deleteVMMutex       sync.RWMutex
	deleteVMArgsForCall []struct {
		instanceID string
	}
	deleteVMReturns struct {
		result1 error
	}
	deleteVMReturnsOnCall map[int]struct {
		result1 error
	}
	GetVMInfoStub        func(name string) (cliaas.VMInfo, error)
	getVMInfoMutex       sync.RWMutex
	getVMInfoArgsForCall []struct {
		name string
	}
	getVMInfoReturns struct {
		result1 cliaas.VMInfo
		result2 error
	}
	getVMInfoReturnsOnCall map[int]struct {
		result1 cliaas.VMInfo
		result2 error
	}
	StartVMStub        func(instanceID string) error
	startVMMutex       sync.RWMutex
	startVMArgsForCall []struct {
		instanceID string
	}
	startVMReturns struct {
		result1 error
	}
	startVMReturnsOnCall map[int]struct {
		result1 error
	}
	StopVMStub        func(instanceID string) error
	stopVMMutex       sync.RWMutex
	stopVMArgsForCall []struct {
		instanceID string
	}
	stopVMReturns struct {
		result1 error
	}
	stopVMReturnsOnCall map[int]struct {
		result1 error
	}
	AssignPublicIPStub        func(instance, ip string) error
	assignPublicIPMutex       sync.RWMutex
	assignPublicIPArgsForCall []struct {
		instance string
		ip       string
	}
	assignPublicIPReturns struct {
		result1 error
	}
	assignPublicIPReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForStatusStub        func(instanceID string, status string) error
	waitForStatusMutex       sync.RWMutex
	waitForStatusArgsForCall []struct {
		instanceID string
		status     string
	}
	waitForStatusReturns struct {
		result1 error
	}
	waitForStatusReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAWSClient) CreateVM(ami string, name string, vmInfo cliaas.VMInfo) (string, error) {
	fake.createVMMutex.Lock()
	ret, specificReturn := fake.createVMReturnsOnCall[len(fake.createVMArgsForCall)]
	fake.createVMArgsForCall = append(fake.createVMArgsForCall, struct {
		ami    string
		name   string
		vmInfo cliaas.VMInfo
	}{ami, name, vmInfo})
	fake.recordInvocation("CreateVM", []interface{}{ami, name, vmInfo})
	fake.createVMMutex.Unlock()
	if fake.CreateVMStub != nil {
		return fake.CreateVMStub(ami, name, vmInfo)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVMReturns.result1, fake.createVMReturns.result2
}

func (fake *FakeAWSClient) CreateVMCallCount() int {
	fake.createVMMutex.RLock()
	defer fake.createVMMutex.RUnlock()
	return len(fake.createVMArgsForCall)
}

func (fake *FakeAWSClient) CreateVMArgsForCall(i int) (string, string, cliaas.VMInfo) {
	fake.createVMMutex.RLock()
	defer fake.createVMMutex.RUnlock()
	return fake.createVMArgsForCall[i].ami, fake.createVMArgsForCall[i].name, fake.createVMArgsForCall[i].vmInfo
}

func (fake *FakeAWSClient) CreateVMReturns(result1 string, result2 error) {
	fake.CreateVMStub = nil
	fake.createVMReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeAWSClient) CreateVMReturnsOnCall(i int, result1 string, result2 error) {
	fake.CreateVMStub = nil
	if fake.createVMReturnsOnCall == nil {
		fake.createVMReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createVMReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeAWSClient) DeleteVM(instanceID string) error {
	fake.deleteVMMutex.Lock()
	ret, specificReturn := fake.deleteVMReturnsOnCall[len(fake.deleteVMArgsForCall)]
	fake.deleteVMArgsForCall = append(fake.deleteVMArgsForCall, struct {
		instanceID string
	}{instanceID})
	fake.recordInvocation("DeleteVM", []interface{}{instanceID})
	fake.deleteVMMutex.Unlock()
	if fake.DeleteVMStub != nil {
		return fake.DeleteVMStub(instanceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteVMReturns.result1
}

func (fake *FakeAWSClient) DeleteVMCallCount() int {
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	return len(fake.deleteVMArgsForCall)
}

func (fake *FakeAWSClient) DeleteVMArgsForCall(i int) string {
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	return fake.deleteVMArgsForCall[i].instanceID
}

func (fake *FakeAWSClient) DeleteVMReturns(result1 error) {
	fake.DeleteVMStub = nil
	fake.deleteVMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) DeleteVMReturnsOnCall(i int, result1 error) {
	fake.DeleteVMStub = nil
	if fake.deleteVMReturnsOnCall == nil {
		fake.deleteVMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) GetVMInfo(name string) (cliaas.VMInfo, error) {
	fake.getVMInfoMutex.Lock()
	ret, specificReturn := fake.getVMInfoReturnsOnCall[len(fake.getVMInfoArgsForCall)]
	fake.getVMInfoArgsForCall = append(fake.getVMInfoArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("GetVMInfo", []interface{}{name})
	fake.getVMInfoMutex.Unlock()
	if fake.GetVMInfoStub != nil {
		return fake.GetVMInfoStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVMInfoReturns.result1, fake.getVMInfoReturns.result2
}

func (fake *FakeAWSClient) GetVMInfoCallCount() int {
	fake.getVMInfoMutex.RLock()
	defer fake.getVMInfoMutex.RUnlock()
	return len(fake.getVMInfoArgsForCall)
}

func (fake *FakeAWSClient) GetVMInfoArgsForCall(i int) string {
	fake.getVMInfoMutex.RLock()
	defer fake.getVMInfoMutex.RUnlock()
	return fake.getVMInfoArgsForCall[i].name
}

func (fake *FakeAWSClient) GetVMInfoReturns(result1 cliaas.VMInfo, result2 error) {
	fake.GetVMInfoStub = nil
	fake.getVMInfoReturns = struct {
		result1 cliaas.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeAWSClient) GetVMInfoReturnsOnCall(i int, result1 cliaas.VMInfo, result2 error) {
	fake.GetVMInfoStub = nil
	if fake.getVMInfoReturnsOnCall == nil {
		fake.getVMInfoReturnsOnCall = make(map[int]struct {
			result1 cliaas.VMInfo
			result2 error
		})
	}
	fake.getVMInfoReturnsOnCall[i] = struct {
		result1 cliaas.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeAWSClient) StartVM(instanceID string) error {
	fake.startVMMutex.Lock()
	ret, specificReturn := fake.startVMReturnsOnCall[len(fake.startVMArgsForCall)]
	fake.startVMArgsForCall = append(fake.startVMArgsForCall, struct {
		instanceID string
	}{instanceID})
	fake.recordInvocation("StartVM", []interface{}{instanceID})
	fake.startVMMutex.Unlock()
	if fake.StartVMStub != nil {
		return fake.StartVMStub(instanceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startVMReturns.result1
}

func (fake *FakeAWSClient) StartVMCallCount() int {
	fake.startVMMutex.RLock()
	defer fake.startVMMutex.RUnlock()
	return len(fake.startVMArgsForCall)
}

func (fake *FakeAWSClient) StartVMArgsForCall(i int) string {
	fake.startVMMutex.RLock()
	defer fake.startVMMutex.RUnlock()
	return fake.startVMArgsForCall[i].instanceID
}

func (fake *FakeAWSClient) StartVMReturns(result1 error) {
	fake.StartVMStub = nil
	fake.startVMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) StartVMReturnsOnCall(i int, result1 error) {
	fake.StartVMStub = nil
	if fake.startVMReturnsOnCall == nil {
		fake.startVMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startVMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) StopVM(instanceID string) error {
	fake.stopVMMutex.Lock()
	ret, specificReturn := fake.stopVMReturnsOnCall[len(fake.stopVMArgsForCall)]
	fake.stopVMArgsForCall = append(fake.stopVMArgsForCall, struct {
		instanceID string
	}{instanceID})
	fake.recordInvocation("StopVM", []interface{}{instanceID})
	fake.stopVMMutex.Unlock()
	if fake.StopVMStub != nil {
		return fake.StopVMStub(instanceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopVMReturns.result1
}

func (fake *FakeAWSClient) StopVMCallCount() int {
	fake.stopVMMutex.RLock()
	defer fake.stopVMMutex.RUnlock()
	return len(fake.stopVMArgsForCall)
}

func (fake *FakeAWSClient) StopVMArgsForCall(i int) string {
	fake.stopVMMutex.RLock()
	defer fake.stopVMMutex.RUnlock()
	return fake.stopVMArgsForCall[i].instanceID
}

func (fake *FakeAWSClient) StopVMReturns(result1 error) {
	fake.StopVMStub = nil
	fake.stopVMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) StopVMReturnsOnCall(i int, result1 error) {
	fake.StopVMStub = nil
	if fake.stopVMReturnsOnCall == nil {
		fake.stopVMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopVMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) AssignPublicIP(instance string, ip string) error {
	fake.assignPublicIPMutex.Lock()
	ret, specificReturn := fake.assignPublicIPReturnsOnCall[len(fake.assignPublicIPArgsForCall)]
	fake.assignPublicIPArgsForCall = append(fake.assignPublicIPArgsForCall, struct {
		instance string
		ip       string
	}{instance, ip})
	fake.recordInvocation("AssignPublicIP", []interface{}{instance, ip})
	fake.assignPublicIPMutex.Unlock()
	if fake.AssignPublicIPStub != nil {
		return fake.AssignPublicIPStub(instance, ip)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.assignPublicIPReturns.result1
}

func (fake *FakeAWSClient) AssignPublicIPCallCount() int {
	fake.assignPublicIPMutex.RLock()
	defer fake.assignPublicIPMutex.RUnlock()
	return len(fake.assignPublicIPArgsForCall)
}

func (fake *FakeAWSClient) AssignPublicIPArgsForCall(i int) (string, string) {
	fake.assignPublicIPMutex.RLock()
	defer fake.assignPublicIPMutex.RUnlock()
	return fake.assignPublicIPArgsForCall[i].instance, fake.assignPublicIPArgsForCall[i].ip
}

func (fake *FakeAWSClient) AssignPublicIPReturns(result1 error) {
	fake.AssignPublicIPStub = nil
	fake.assignPublicIPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) AssignPublicIPReturnsOnCall(i int, result1 error) {
	fake.AssignPublicIPStub = nil
	if fake.assignPublicIPReturnsOnCall == nil {
		fake.assignPublicIPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.assignPublicIPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) WaitForStatus(instanceID string, status string) error {
	fake.waitForStatusMutex.Lock()
	ret, specificReturn := fake.waitForStatusReturnsOnCall[len(fake.waitForStatusArgsForCall)]
	fake.waitForStatusArgsForCall = append(fake.waitForStatusArgsForCall, struct {
		instanceID string
		status     string
	}{instanceID, status})
	fake.recordInvocation("WaitForStatus", []interface{}{instanceID, status})
	fake.waitForStatusMutex.Unlock()
	if fake.WaitForStatusStub != nil {
		return fake.WaitForStatusStub(instanceID, status)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitForStatusReturns.result1
}

func (fake *FakeAWSClient) WaitForStatusCallCount() int {
	fake.waitForStatusMutex.RLock()
	defer fake.waitForStatusMutex.RUnlock()
	return len(fake.waitForStatusArgsForCall)
}

func (fake *FakeAWSClient) WaitForStatusArgsForCall(i int) (string, string) {
	fake.waitForStatusMutex.RLock()
	defer fake.waitForStatusMutex.RUnlock()
	return fake.waitForStatusArgsForCall[i].instanceID, fake.waitForStatusArgsForCall[i].status
}

func (fake *FakeAWSClient) WaitForStatusReturns(result1 error) {
	fake.WaitForStatusStub = nil
	fake.waitForStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) WaitForStatusReturnsOnCall(i int, result1 error) {
	fake.WaitForStatusStub = nil
	if fake.waitForStatusReturnsOnCall == nil {
		fake.waitForStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAWSClient) SwapLb(identifier string, vmidentifiers []string) error {
	return nil
}

func (fake *FakeAWSClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createVMMutex.RLock()
	defer fake.createVMMutex.RUnlock()
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	fake.getVMInfoMutex.RLock()
	defer fake.getVMInfoMutex.RUnlock()
	fake.startVMMutex.RLock()
	defer fake.startVMMutex.RUnlock()
	fake.stopVMMutex.RLock()
	defer fake.stopVMMutex.RUnlock()
	fake.assignPublicIPMutex.RLock()
	defer fake.assignPublicIPMutex.RUnlock()
	fake.waitForStatusMutex.RLock()
	defer fake.waitForStatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAWSClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cliaas.AWSClient = new(FakeAWSClient)
